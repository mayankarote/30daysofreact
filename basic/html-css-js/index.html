<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript</title>
</head>
<body>
<h1 style="color: red;">The let Keyword </h1>
<h3>The let keyword allows you to declare a variable with block scope.</h3>

<h4>var y is Global variable so x+2 is </h4><p id="demo"></p>
<h4>because of let z variable it print with in a curly braces</h4><p id="demo1"></p>
<h4>X is Global variable so x is</h4><p id="demo2"></p>
<h4>because of let z variable it don't print value</h4><p id="demo3"></p>

<script>
    var x = 10;
    // Here x is 10
    {
        let x = 2;
        // Here x is 2
        var y = x+2;
         document.getElementById("demo").innerHTML = y;
         let z= x+2;
         document.getElementById("demo1").innerHTML = z;
    }
    // Here x is 10
    document.getElementById("demo2").innerHTML = x;
    document.getElementById("demo3").innerHTML = z
</script>

<h1 style="color: red;">The Const Keyword </h1>
<h3>The const keyword allows you to declare a constant (a JavaScript variable with a constant value). Constants are similar to let variables, except that the value cannot be changed.</h3>

    <p id="pq1"></p> 
    <p id="pq"></p>
    <script>
        var p = 10;
        // Here x is 10
        {
            const q = 2;
            // Here x is 2
            document.getElementById("pq").innerHTML = q;
         }
        // Here x is 10
        document.getElementById("pq1").innerHTML = p;
    </script>

<h1 style="color: red;">Arrow Fuctions </h1>
<h3>Arrow functions allows a short syntax for writing function expressions.
You don't need the function keyword, the return keyword, and the curly brackets.</h3>
<p id="demo6"></p>

<script>
    // var x = function (x, y) {
    //         return x * y;
    //     }
    const a = (b, c) => b * c;
    document.getElementById("demo6").innerHTML = a(5, 5);
</script>

<h4>Arrow functions do not have their own this. They are not well suited for defining object methods. Arrow functions are not hoisted. They must be defined before they are used.
Using const is safer than using var, because a function expression is always a constant value. You can only omit the return keyword and the curly brackets if the function is a single statement. Because of this, it might be a good habit to always keep them:</h4>

<h1 style="color: red;">For/of loop</h1>
<h4>The JavaScript for/of statement loops through the values of an iterable objects.
for/of lets you loop over data structures that are iterable such as Arrays, Strings, Maps, NodeLists, and more.
The for/of loop has the following syntax:
    for (variable of iterable) {
    // code block to be executed
    }
variable - For every iteration the value of the next property is assigned to the variable. Variable can be declared with const, let, or var.
iterable - An object that has iterable properties.</h4>
<p>Looping</p>

<p id="demo4"></p>
<script>
    let cars = ["BMW", "Volvo", "Mini"];
    let text = "";

    for (let m of cars) {
        text += m + "<br>";
    }
    document.getElementById("demo4").innerHTML = text.fontcolor("blue");
</script>

<h4>Looping over string</h4>
<p id="demo7"></p>
<script>
    let language = "JavaScript";
    let txt = "";

    for (let n of language) {
        txt += n + "<br>";
    }
    document.getElementById("demo7").innerHTML = txt.fontcolor("blue");
</script>

<h1 style="color: red;">JavaScript Classes</h1>
<h4>JavaScript Classes are templates for JavaScript Objects.
    Use the keyword class to create a class. Always add a method named constructor()</h4>

    <p id="demo_class"></p>

    <script>
        class Car {
            constructor(name, year) {
                this.name = name;
                this.year = year;
            }
        }

        myCar = new Car("Ford", 2014);
        document.getElementById("demo_class").innerHTML =
            myCar.name + " " + myCar.year;
    </script>

<h1 style="color: red;">JavaScript Promises</h1>
<h1 id="demo_promises"></h1>

<script>
    let myPromise = new Promise((resolve, reject) => {
        let a = 1 + 3;
        if (a == 2) {
            setTimeout(function () { resolve("Correct !!"); }, 3000);
        } else {
            setTimeout(function () { resolve("Wrong !!"); }, 3000);
        }
    });

    myPromise.then((value) => {
        document.getElementById("demo_promises").innerHTML = value;
    }).catch((value) => {
        document.getElementById("demo_promises").innerHTML = value;
    })
</script>

<h4>Other Example of Promises</h4>
<p id="demo_promise1"></p>
<script>
    const recordVideoOne = new Promise((resolve, reject)=>{
        resolve('Video 1 Recorded');
    })
    const recordVideoTwo = new Promise((resolve, reject) => {
            resolve('Video 2 Recorded');
        })

    const recordVideoThree = new Promise((resolve, reject) => {
        resolve('Video 3 Recorded');
    })
Promise.all([recordVideoOne, recordVideoTwo, recordVideoThree]).then((messages)=>{
    document.getElementById(demo_promise1).innerHTML= messages;
})
</script>
<h1 style="color: red;">Symbol Type</h1>
<h4>A JavaScript Symbol is a primitive datatype just like Number, String, or Boolean.
It represents a unique "hidden" identifier that no other code can accidentally access.
For instance, if different coders want to add a person.id property to a person object belonging to a third-party code,they could mix each others values.
Using Symbol() to create a unique identifiers, solves this problem:</h4>

<p id="demo_symbol"></p>
<p id="demo1_symbol"></p>

<script>
    const person = {
        firstName: "John",
        lastName: "Doe",
        age: 50,
        eyeColor: "blue"
    };

    const person1 = {
        firstName: "vampire",
        lastName: "xyz",
        age: 100,
        eyeColor: "red"
    };

    let id = Symbol('id');
    person.id = 140353;
    person1.id = 56767;

    document.getElementById("demo_symbol").innerHTML = person.id;
    document.getElementById("demo1_symbol").innerHTML = person1.id;
</script>

<h1 style="color: red;">Default Parameter Values</h1>
<p id="demo_values"></p>
<script>
    function myFunction(x, y = 15) {
        // y is 10 if not passed or undefined
        return x + y;
    }
    document.getElementById("demo_values").innerHTML = myFunction(5);
</script>

    <h3>JavaScript Function Rest Parameter</h3>
    <p>The rest parameter (...) allows a function to treat an indefinite number of arguments as an array:</p>
    
    <p id="demo_rest"></p>
    <script>
        function sum(...args) {
            let sum = 0;
            for (let arg of args) sum += arg;
            return sum;
        }
        let x_r = sum(4, 9, 16, 25, 29, 100, 66, 77);
        document.getElementById("demo_rest").innerHTML = x_r;
    </script>

<h1 style="color: red;">Array.find()</h1>
<h4>1.The item value
    2.The item index
    3.The array itself

    Array.findIndex():-The findIndex() method returns the index of the first array element that passes a test function.</h4>
<p id="demo_find"></p>

<script>
    var numbers = [4, 9, 16, 25, 29];
    var first = numbers.find(myFunction);
    document.getElementById("demo_find").innerHTML = "First number over 18 is " + first;
    function myFunction(value, index, array) {
        return value > 18;
    }
</script>

<h1 style="color: red;">New Number Properties</h1>
    
    <p>1.EPSILON</p>
    <p>2.MIN_SAFE_INTEGER</p>
    <p>3.MAX_SAFE_INTEGER</p>
    
    <p id="demo_EPSILON"></p>
    <p id="demo_MIN_SAFE_INTEGER"></p>
    <p id="demo_MAX_SAFE_INTEGER"></p>
    
    <script>
        var x_EPSILON = Number.EPSILON;
        document.getElementById("demo_EPSILON").innerHTML = x_EPSILON;

        var x_MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
        document.getElementById("demo_MIN_SAFE_INTEGER").innerHTML = x_MIN_SAFE_INTEGER;

        var x_MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
        document.getElementById("demo_MAX_SAFE_INTEGER").innerHTML = x_MAX_SAFE_INTEGER;
    </script>
<h1 style="color: red;">New Number Methods</h1>
<h4>1.Number.isInteger(): The Number.isInteger() method returns true if the argument is an integer. Otherwise it returns false</h4>
    
    <p id="demo_method"></p>
    <script>
        document.getElementById("demo_method").innerHTML =
            Number.isInteger(10) + "<br>" + Number.isInteger(10.5);
    </script>

<h4>2.Number.isSafeInteger(): A safe integer is an integer that can be exactly represented as a double precision number. The Number.isSafeInteger() method returns true if the argument is a safe integer.Otherwise it returns false.</h4>
    
    <p id="demo_method1"></p>
    <script>
        document.getElementById("demo_method1").innerHTML =
            Number.isSafeInteger(10) + "<br>" + Number.isSafeInteger(12345678901234567890);
    </script>

<h1 style="color: red;">New Global Methods</h1>
    ES6 added 2 new global number methods:
    
    <h4>1.The isFinite(): The global isFinite() method returns false if the argument is Infinity or NaN. Otherwise it returns true:</h4>

    <p id="demo_global"></p>
    <script>
        document.getElementById("demo_global").innerHTML =
            isFinite(10 / 0) + "<br>" + isFinite(10 / 1);
    </script>
    <h4>The isNaN():The global isNaN() method returns true if the argument is NaN. Otherwise it returns false:</h4>

        <p id="demo_globall"></p>
        <script>
            document.getElementById("demo_globall").innerHTML =
                isNaN("Hello") + "<br>" + isNaN("10");
        </script>
<h1 style="color: red;">Array/Object Destructuring</h1>
<h3>Basic Array Destructuring</h3>
    <script>
       let [greeting, pronoun] = ["Hello", "I", "am", "Sarah"];
 
        console.log(greeting);//"Hello"
        console.log(pronoun);//"I"
    </script>

<h3>Declaring Variables before Assignment</h3>
<script>
    let greeting, pronoun;
    [greeting, pronoun] = ["Hello", "I", "am", "Sarah"];

    console.log(greeting);//"Hello"
    console.log(pronoun);//"I"
</script>

<h3>Skipping Items in an Array</h3>
<script>
    let [greeting, , , name] = ["Hello", "I", "am", "Sarah"];

    console.log(greeting);//"Hello"
    console.log(name);//"Sarah"
</script>

<h3>Assigning the rest of an array</h3>
<script>
    let [greeting, ...intro] = ["Hello", "I", "am", "Sarah"];

    console.log(greeting);//"Hello"
    console.log(intro);//["I", "am", "Sarah"]

</script>

<h3>Destructuring Assignment with Functions</h3>
<script>
    function getArray() {
       return ["Hello", "I", "am", "Sarah"];
    }
    let [greeting, pronoun] = getArray();
    console.log(greeting);//"Hello"
    console.log(pronoun);//"I"
</script>

<h3>Swapping Values using the Destructuring Assignment</h3>
<script>
    let a = 3;
    let b = 6;
    [a, b] = [b, a];

    console.log(a);//6
    console.log(b);//3
</script>

<h1 style="color: red;">Basic Object Destructuring</h1>

<script>
    function getArray() {
       return ["Hello", "I", "am", "Sarah"];
    }
    let [greeting, pronoun] = getArray();
    console.log(greeting);//"Hello"
    console.log(pronoun);//"I"
</script>

<h3>Using a new Variable Name</h3>
<p>If we want to assign values of an object to a new variable instead of using the name of the property, we can do this:</p>
<script>
   let person = { name: "Sarah", country: "Nigeria", job: "Developer" };

    let { name: foo, job: bar } = person;

    console.log(foo);//"Sarah"
    console.log(bar);//"Developer"

</script>

<h3>Combining Arrays with Objects</h3>
<script>
    let person = { name: "Sarah", country: "Nigeria", friends: ["Annie", "Becky"] };

        let { name: foo, friends: bar } = person;

        console.log(foo);//"Sarah"
        console.log(bar);//["Annie", "Becky"]

</script>

<h3>Rest in Object Destructuring</h3>
<script>
    let person = { name: "Sarah", country: "Nigeria", job: "Developer" friends: ["Annie", "Becky"] };

        let { name, friends, ...others } = person;

        console.log(name);//"Sarah"
        console.log(friends);//["Annie", "Becky"]
        console.log(others);// {country: "Nigeria", job: "Developer"}
</script>

</body>
</html>