<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript</title>
</head>
<body>
    <h1 style="color: darkred; text-align: center;">ES6</h1>
    <hr>
<h2 style="color: red;">The let Keyword </h2>
<h3>The let keyword allows you to declare a variable with block scope.</h3>

<h4>var y is Global variable so x+2 is </h4><p id="demo"></p>
<h4>because of let z variable it print with in a curly braces</h4><p id="demo1"></p>
<h4>X is Global variable so x is</h4><p id="demo2"></p>
<h4>because of let z variable it don't print value</h4><p id="demo3"></p>

<script>
    var x = 10;
    // Here x is 10
    {
        let x = 2;
        // Here x is 2
        var y = x+2;
         document.getElementById("demo").innerHTML = y;
         let z= x+2;
         document.getElementById("demo1").innerHTML = z;
    }
    // Here x is 10
    document.getElementById("demo2").innerHTML = x;
    document.getElementById("demo3").innerHTML = z
</script>

<h2 style="color: red;">The Const Keyword </h2>
<h3>The const keyword allows you to declare a constant (a JavaScript variable with a constant value). Constants are similar to let variables, except that the value cannot be changed.</h3>

    <p id="pq1"></p> 
    <p id="pq"></p>
    <script>
        var p = 10;
        // Here x is 10
        {
            const q = 2;
            // Here x is 2
            document.getElementById("pq").innerHTML = q;
         }
        // Here x is 10
        document.getElementById("pq1").innerHTML = p;
    </script>

<h2 style="color: red;">Arrow Fuctions </h2>
<h3>Arrow functions allows a short syntax for writing function expressions.
You don't need the function keyword, the return keyword, and the curly brackets.</h3>
<p id="demo6"></p>

<script>
    // var x = function (x, y) {
    //         return x * y;
    //     }
    const a = (b, c) => b * c;
    document.getElementById("demo6").innerHTML = a(5, 5);
</script>

<h4>Arrow functions do not have their own this. They are not well suited for defining object methods. Arrow functions are not hoisted. They must be defined before they are used.
Using const is safer than using var, because a function expression is always a constant value. You can only omit the return keyword and the curly brackets if the function is a single statement. Because of this, it might be a good habit to always keep them:</h4>

<h2 style="color: red;">For/of loop</h2>
<h4>The JavaScript for/of statement loops through the values of an iterable objects.
for/of lets you loop over data structures that are iterable such as Arrays, Strings, Maps, NodeLists, and more.
The for/of loop has the following syntax:
    for (variable of iterable) {
    // code block to be executed
    }
variable - For every iteration the value of the next property is assigned to the variable. Variable can be declared with const, let, or var.
iterable - An object that has iterable properties.</h4>
<p>Looping</p>

<p id="demo4"></p>
<script>
    let cars = ["BMW", "Volvo", "Mini"];
    let text = "";

    for (let m of cars) {
        text += m + "<br>";
    }
    document.getElementById("demo4").innerHTML = text.fontcolor("blue");
</script>

<h4>Looping over string</h4>
<p id="demo7"></p>
<script>
    let language = "JavaScript";
    let txt = "";

    for (let n of language) {
        txt += n + "<br>";
    }
    document.getElementById("demo7").innerHTML = txt.fontcolor("blue");
</script>

<h2 style="color: red;">JavaScript Classes</h2>
<h4>JavaScript Classes are templates for JavaScript Objects.
    Use the keyword class to create a class. Always add a method named constructor()</h4>

    <p id="demo_class"></p>

    <script>
        class Car {
            constructor(name, year) {
                this.name = name;
                this.year = year;
            }
        }

        myCar = new Car("Ford", 2014);
        document.getElementById("demo_class").innerHTML =
            myCar.name + " " + myCar.year;
    </script>

<h2 style="color: red;">JavaScript Promises</h2>
<p id="demo_promises"></p>

<script>
    let myPromise = new Promise((resolve, reject) => {
        let a = 1 + 3;
        if (a == 2) {
            setTimeout(function () { resolve("Correct !!"); }, 3000);
        } else {
            setTimeout(function () { resolve("Wrong !!"); }, 3000);
        }
    });

    myPromise.then((value) => {
        document.getElementById("demo_promises").innerHTML = value;
    }).catch((value) => {
        document.getElementById("demo_promises").innerHTML = value;
    })
</script>

<h4>Other Example of Promises</h4>
<p id="demo_promise1"></p>
<script>
    const recordVideoOne = new Promise((resolve, reject)=>{
        resolve('Video 1 Recorded');
    })
    const recordVideoTwo = new Promise((resolve, reject) => {
            resolve('Video 2 Recorded');
        })

    const recordVideoThree = new Promise((resolve, reject) => {
        resolve('Video 3 Recorded');
    })
Promise.all([recordVideoOne, recordVideoTwo, recordVideoThree]).then((messages)=>{
    document.getElementById(demo_promise1).innerHTML= messages;
})
</script>

<h2 style="color: red;">Symbol Type</h2>
<h4>A JavaScript Symbol is a primitive datatype just like Number, String, or Boolean.
It represents a unique "hidden" identifier that no other code can accidentally access.
For instance, if different coders want to add a person.id property to a person object belonging to a third-party code,they could mix each others values.
Using Symbol() to create a unique identifiers, solves this problem:</h4>

<p id="demo_symbol"></p>
<p id="demo1_symbol"></p>

<script>
    const person = {
        firstName: "John",
        lastName: "Doe",
        age: 50,
        eyeColor: "blue"
    };

    const person1 = {
        firstName: "vampire",
        lastName: "xyz",
        age: 100,
        eyeColor: "red"
    };

    let id = Symbol('id');
    person.id = 140353;
    person1.id = 56767;

    document.getElementById("demo_symbol").innerHTML = person.id;
    document.getElementById("demo1_symbol").innerHTML = person1.id;
</script>

<h2 style="color: red;">Default Parameter Values</h2>
<p id="demo_values"></p>
<script>
    function myFunction(x, y = 15) {
        // y is 10 if not passed or undefined
        return x + y;
    }
    document.getElementById("demo_values").innerHTML = myFunction(5);
</script>

    <h3>JavaScript Function Rest Parameter</h3>
    <p>The rest parameter (...) allows a function to treat an indefinite number of arguments as an array:</p>
    
    <p id="demo_rest"></p>
    <script>
        function sum(...args) {
            let sum = 0;
            for (let arg of args) sum += arg;
            return sum;
        }
        let x_r = sum(4, 9, 16, 25, 29, 100, 66, 77);
        document.getElementById("demo_rest").innerHTML = x_r;
    </script>

<h2 style="color: red;">Array.find()</h2>
<h4>1.The item value
    2.The item index
    3.The array itself

    Array.findIndex():-The findIndex() method returns the index of the first array element that passes a test function.</h4>
<p id="demo_find"></p>

<script>
    var numbers = [4, 9, 16, 25, 29];
    var first = numbers.find(myFunction);
    document.getElementById("demo_find").innerHTML = "First number over 18 is " + first;
    function myFunction(value, index, array) {
        return value > 18;
    }
</script>

<h2 style="color: red;">New Number Properties</h2>
    
    <p>1.EPSILON</p>
    <p>2.MIN_SAFE_INTEGER</p>
    <p>3.MAX_SAFE_INTEGER</p>
    
    <p id="demo_EPSILON"></p>
    <p id="demo_MIN_SAFE_INTEGER"></p>
    <p id="demo_MAX_SAFE_INTEGER"></p>
    
    <script>
        var x_EPSILON = Number.EPSILON;
        document.getElementById("demo_EPSILON").innerHTML = x_EPSILON;

        var x_MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
        document.getElementById("demo_MIN_SAFE_INTEGER").innerHTML = x_MIN_SAFE_INTEGER;

        var x_MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
        document.getElementById("demo_MAX_SAFE_INTEGER").innerHTML = x_MAX_SAFE_INTEGER;
    </script>
<h2 style="color: red;">New Number Methods</h2>
<h4>1.Number.isInteger(): The Number.isInteger() method returns true if the argument is an integer. Otherwise it returns false</h4>
    
    <p id="demo_method"></p>
    <script>
        document.getElementById("demo_method").innerHTML =
            Number.isInteger(10) + "<br>" + Number.isInteger(10.5);
    </script>

<h4>2.Number.isSafeInteger(): A safe integer is an integer that can be exactly represented as a double precision number. The Number.isSafeInteger() method returns true if the argument is a safe integer.Otherwise it returns false.</h4>
    
    <p id="demo_method1"></p>
    <script>
        document.getElementById("demo_method1").innerHTML =
            Number.isSafeInteger(10) + "<br>" + Number.isSafeInteger(12345678901234567890);
    </script>

<h1 style="color: red;">New Global Methods</h1>
    ES6 added 2 new global number methods:
    
    <h4>1.The isFinite(): The global isFinite() method returns false if the argument is Infinity or NaN. Otherwise it returns true:</h4>

    <p id="demo_global"></p>
    <script>
        document.getElementById("demo_global").innerHTML =
            isFinite(10 / 0) + "<br>" + isFinite(10 / 1);
    </script>
    <h4>The isNaN():The global isNaN() method returns true if the argument is NaN. Otherwise it returns false:</h4>

        <p id="demo_globall"></p>
        <script>
            document.getElementById("demo_globall").innerHTML =
                isNaN("Hello") + "<br>" + isNaN("10");
        </script>


<h2 style="color: red;">Array/Object Destructuring</h2>
<h3>Basic Array Destructuring</h3>
    <script>
       let [greeting, pronoun] = ["Hello", "I", "am", "Sarah"];
 
        console.log(greeting);//"Hello"
        console.log(pronoun);//"I"
    </script>

<h3>Declaring Variables before Assignment</h3>
<script>
    let greeting, pronoun;
    [greeting, pronoun] = ["Hello", "I", "am", "Sarah"];

    console.log(greeting);//"Hello"
    console.log(pronoun);//"I"
</script>

<h3>Skipping Items in an Array</h3>
<script>
    let [greeting, , , name] = ["Hello", "I", "am", "Sarah"];

    console.log(greeting);//"Hello"
    console.log(name);//"Sarah"
</script>

<h3>Assigning the rest of an array</h3>
<script>
    let [greeting, ...intro] = ["Hello", "I", "am", "Sarah"];

    console.log(greeting);//"Hello"
    console.log(intro);//["I", "am", "Sarah"]

</script>

<h3>Destructuring Assignment with Functions</h3>
<script>
    function getArray() {
       return ["Hello", "I", "am", "Sarah"];
    }
    let [greeting, pronoun] = getArray();
    console.log(greeting);//"Hello"
    console.log(pronoun);//"I"
</script>

<h3>Swapping Values using the Destructuring Assignment</h3>
<script>
    let a = 3;
    let b = 6;
    [a, b] = [b, a];

    console.log(a);//6
    console.log(b);//3
</script>

<h2 style="color: red;">Basic Object Destructuring</h2>
<script>
    function getArray() {
       return ["Hello", "I", "am", "Sarah"];
    }
    let [greeting, pronoun] = getArray();
    console.log(greeting);//"Hello"
    console.log(pronoun);//"I"
</script>

<h3>Using a new Variable Name</h3>
<p>If we want to assign values of an object to a new variable instead of using the name of the property, we can do this:</p>
<script>
   let person = { name: "Sarah", country: "Nigeria", job: "Developer" };
    let { name: foo, job: bar } = person;

    console.log(foo);//"Sarah"
    console.log(bar);//"Developer"
</script>

<h3>Combining Arrays with Objects</h3>
<script>
    let person = { name: "Sarah", country: "Nigeria", friends: ["Annie", "Becky"] };

        let { name: foo, friends: bar } = person;

        console.log(foo);//"Sarah"
        console.log(bar);//["Annie", "Becky"]

</script>

<h3>Rest in Object Destructuring</h3>
<script>
    let person = { name: "Sarah", country: "Nigeria", job: "Developer", friends: ["Annie", "Becky"] };

        let { name, friends, ...others } = person;

        console.log(name);//"Sarah"
        console.log(friends);//["Annie", "Becky"]
        console.log(others);// {country: "Nigeria", job: "Developer"}
</script>

<h2 style="color: red;">Array/Object Spread Operator</h2>
<p>spread operator that consists of three dots (...). The spread operator allows you to spread out elements of an iterable object such as an array,a map, or a set.</p><script>
    const odd = [1, 3, 5];
    const combined = [2, 4, 6, ...odd];
    console.log(combined);
</script>

<h4>the rest parameter (...) collects the arguments 3,4 and 5 into an array args.
So the three dots ( ...) represent both the spread operator and the rest parameter.
Here are the main differences:
1. The spread operator unpacks elements.
2. The rest parametr packs elements into an array.
The rest parameters must be the last arguments of a function. However, the spread operator can be anywhere:</h4>
<script>
    const odd = [1, 3, 5];
    const combined = [...odd, 2, 4, 6];
    console.log(combined);
</script>
<h4>
    1.The spread operator is denoted by three dots (…).
    2.The spread operator unpacks elements of iterable objects such as arrays, sets, and maps into a list.
    3.The rest paramter is also denoted by three dots (…). However, it packs remaining arguments of a function into an array.
    4.The spread operator can be used to clone an iterable object or merge iterable objects into one.
</h4>

<h2 style="color: red;">Backtick in javascript</h2>
<h4>These literals do allow basic string interpolation expressions to be embedded, which are then automatically parsed and evaluated</h4>
<script>
    const age = 3
    console.log(`I'm ${age} years old!`)
</script>
<hr>

<h1 style="color: darkred; text-align: center;">ES7</h1>
<hr>
<h2 style="color: red;">Array.Prototype.include()</h2>
<h4>Array.prototype.includes() checks the array for the value passed as an argument. It returns true if the array contains the value, otherwise, it returns false.
Array.prototype.includes() returns the correct value when searching for NaN.
NaN is a property of the JavaScript global object and represents a value that is Not-a-Number. There are known quirks when comparing NaN to another value. These are addressed in Array.prototype.includes(),but not in Array.protoype.indexOf.</h4>

<script>
    let numbers = [1, 2, 3, 4, NaN];
    console.log(numbers.indexOf(NaN)); //Prints -1console.log(numbers.includes(NaN)); //Prints true
</script>

<h2 style="color: red;">Exponentiation Operator</h2>
<h4>It has the same purpose as Math.pow(). It returns the first argument raised to the power of the second argument.</h4>
<script>
    let base = 3; let exponent = 4; let result = base ** exponent;
    console.log(result); //81
</script>
<hr>

<h1 style="color: darkred; text-align: center;">ES8</h1>
<hr>
<h2>Async Function</h2>
<h4>Asynchronous code is at the core of JavaScript, and ES8 has officially added the ability to declare a function as async.
By adding the async keyword in front of a function, you are able to defer the execution of code using the awaitstatement. The return value of an async function is implicitly a promise object</h4>

<script>
    async function getDataFromAjax(url) {
        let data;
        try {
            data = await fetch(url);
            // This will wait 
            // until fetch returns
            fillClientStateWithData(data.json());
        } catch (error) {
            // This will execute if the
            // API returns an error
            handleAjaxError(error);
        }
    }
    getDataFromAjax();
</script>

<h2 style="color: red;">Padding a String</h2>
<h4>two string handling functions for padding a string. These functions can be used to add space or any
desired set of characters to the beginning and end of a string value.
</h4>
<h3>String. padStart(): </h3><p>This function pads the current string with a given input string repeatedly from the start, till the current string reaches the given length. 
The padStart() function accepts two parameters which are as follows −

<u>targetLength</u> − A numeric value that represents the target length of the string after padding. If the value of this
parameter is lesser than or equal to the existing length of the string, the string value is returned as it is.

<u>padString</u> − This is an optional parameter. This parameter specifies the characters that should be used to pad thestring. The string value is padded with spaces if no value is passed to this parameter.</p>
<script>
            //pad the String with 0
            let product_cost = '1699'.padStart(7,0)
            console.log(product_cost)
            console.log(product_cost.length)

            //pad the String with blank spaces
            let product_cost1 = '1699'.padStart(7)
            console.log(product_cost1)
            console.log(product_cost1.length)
            //output:-0001699 , 7, 1699,7
   </script>

</body>
</html>